\section{Equations}

To write an equation

\begin{verbatim}
\begin{eqnarray}\label{eq1}
F = m \times a
\end{eqnarray}
\end{verbatim}

\noindent This will produce

\begin{eqnarray}\label{eq1}
F = m \times a
\end{eqnarray}

\noindent To refer to the equation

\begin{verbatim}
\eqref{eq1}
\end{verbatim}

\noindent This will produce \eqref{eq1}.


\section{Figures}
To create a figure

\begin{verbatim}
\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{fig/pikachu}
  \caption{Pikachu.}
\label{fig1}
\end{figure}
\end{verbatim}

\begin{figure}[h!]
  \centering
    \includegraphics[width=0.5\textwidth]{fig/pikachu}
 \caption{Pikachu.}
\label{fig1}
\end{figure}

\noindent To refer to the figure

\begin{verbatim}
\textbf{Fig. \ref{fig1}}
\end{verbatim}

\noindent This will produce \textbf{Fig. \ref{fig1}}

\section{References}

To cite references

\begin{verbatim}
\cite{1,2,3}
\end{verbatim}
or
\begin{verbatim}
\citep{1,2,3}
\end{verbatim}

%\noindent This will produce: \cite{1,2,3} or \citep{1,2,3}, respectively.

\section{Tables}

To create a table

\begin{verbatim}
\begin{table}[!h]
\begin{center}
    \begin{tabular}{ | l | l | l | l |}
    \hline
    \textbf{No.} & \textbf{Data 1} & \textbf{Data 2} \\ \hline
     1 & a1 & b1 \\ \hline
     2 & a2 & b2 \\ \hline
    \end{tabular}
\end{center}
\caption{Table 1.}
\label{Tab1}
\end{table}
\end{verbatim}

\noindent This will produce

\begin{table}[!h]
\begin{center}
    \begin{tabular}{ | l | l | l | l |}
    \hline
    \textbf{No.} & \textbf{Data 1} & \textbf{Data 2} \\ \hline
     1 & a1 & b1 \\ \hline
     2 & a2 & b2 \\ \hline
    \end{tabular}
\end{center}
\caption{Table 1.}
\label{Tab1}
\end{table}

\noindent To refer to the table

\begin{verbatim}
\textbf{Table. \ref{Tab1}}
\end{verbatim}

\noindent This will produce \textbf{Table. \ref{Tab1}}.

% ============================ section ===============================
\section{Notes}

The segmentation issue due to lack of plasticity as previously mentioned is most likely still present in today's deep neural networks. -> Should be addressed.
Broadcasting, in general: Array broadcast to have a compatible size with another (larger) array.

Python's memory management does not return a deallocated memory buffer to the OS, it only marks it as free for reuse by Python. This results in large lists that are only created temporarily to consume the list's size of memory after it is freed. Some of this seems to live on even when data structures are pickled (i.e. the internal state is saved to memory for unpickling later on). Therefore, saving results during experimental execution may benefit from being saved to custom formats in plain text-files.

Theano has an aggressive reuse of memory, which is largely what makes its code fast (). Theano has its own memory space, which does not usually overlap with Python's.